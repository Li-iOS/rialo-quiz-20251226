<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rialo SFS Quiz - Dual Language</title>
    <style>
        :root {
            --primary: #5856d6;
            --secondary: #f0f0f7;
            --success: #28a745;
            --error: #dc3545;
            --text: #1d1d1f;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #f5f5f7;
            display: flex;
            justify-content: center;
            margin: 0;
            padding: 20px;
            color: var(--text);
        }
        .container {
            background: white;
            width: 100%;
            max-width: 750px;
            padding: 40px;
            border-radius: 24px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.05);
            position: relative;
        }
        /* 语言切换按钮样式 */
        .lang-switch {
            position: absolute;
            top: 20px;
            right: 20px;
        }
        .lang-btn {
            background: var(--secondary);
            border: 1px solid #ddd;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .lang-btn:hover { background: #e2e2ee; }

        .header { text-align: center; margin-bottom: 30px; }
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: var(--secondary);
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }
        .question-num { color: var(--primary); font-weight: bold; margin-bottom: 10px; }
        .question-text { font-size: 1.25rem; font-weight: 600; margin-bottom: 25px; line-height: 1.5; }
        .options { display: grid; gap: 12px; }
        .option {
            padding: 16px 20px;
            border: 2px solid var(--secondary);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            display: flex;
            align-items: center;
        }
        .option:hover:not(.disabled) { border-color: var(--primary); background: #fcfcff; }
        .option.correct { background: var(--success) !important; color: white !important; border-color: var(--success) !important; }
        .option.wrong { background: var(--error) !important; color: white !important; border-color: var(--error) !important; }
        .option.disabled { cursor: not-allowed; opacity: 0.8; }
        
        .feedback {
            margin-top: 25px;
            padding: 20px;
            border-radius: 12px;
            display: none;
            background: #f8f9fa;
            border-left: 5px solid var(--primary);
            font-size: 0.95rem;
            line-height: 1.6;
        }
        .footer-btns { margin-top: 30px; display: flex; justify-content: flex-end; }
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            background: var(--primary);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            display: none;
        }
        #result-box { text-align: center; display: none; }
        .score-display { font-size: 4rem; font-weight: 800; color: var(--primary); margin: 20px 0; }
        @media (max-width: 480px) { .container { padding: 20px; } }
    </style>
</head>
<body>

<div class="container">
    <div class="lang-switch">
        <button class="lang-btn" onclick="toggleLang()" id="lang-toggle-btn">English / 中文</button>
    </div>

    <div id="quiz-box">
        <div class="header">
            <h2 id="ui-title">Rialo SFS 模型评测</h2>
            <p id="ui-subtitle" style="color: #666;">深度掌握去中心化经济模型</p>
        </div>
        <div class="progress-bar-container">
            <div id="progress-fill"></div>
        </div>
        <div class="question-num"><span id="ui-q-prefix">问题</span> <span id="current-idx">1</span> / 30</div>
        <div class="question-text" id="question-text">Loading...</div>
        <div class="options" id="options-container"></div>
        <div class="feedback" id="feedback"></div>
        <div class="footer-btns">
            <button class="btn" id="next-btn" onclick="nextQuestion()">Next →</button>
        </div>
    </div>

    <div id="result-box">
        <h2 id="ui-res-title">测试完成！</h2>
        <div class="score-display"><span id="final-score">0</span>%</div>
        <p id="score-comment"></p>
        <button class="btn" style="display:inline-block; margin-top: 20px;" onclick="location.reload()" id="ui-retry-btn">重新开始</button>
    </div>
</div>

<script>
    let currentLang = 'zh'; // 'zh' or 'en'
    
    const uiStrings = {
        zh: {
            title: "Rialo SFS 模型评测",
            subtitle: "深度掌握去中心化经济模型",
            qPrefix: "问题",
            next: "下一题 →",
            resTitle: "测试完成！",
            retry: "重新开始",
            explanation: "解析：",
            perfect: "完美的表现！你已成为 Rialo 经济模型专家。",
            good: "非常优秀！你对 SFS 有着深入的理解。",
            pass: "及格了，建议针对错题再复习一下。",
            fail: "还需要努力，建议重新阅读 Rialo 的官方文档。"
        },
        en: {
            title: "Rialo SFS Model Evaluation",
            subtitle: "Master the Decentralized Economic Model",
            qPrefix: "Question",
            next: "Next Question →",
            resTitle: "Quiz Completed!",
            retry: "Restart",
            explanation: "Explanation: ",
            perfect: "Perfect! You are an expert on the Rialo SFS model.",
            good: "Great job! You have a deep understanding of SFS.",
            pass: "Passed. You might want to review the wrong answers.",
            fail: "Need more study. We recommend re-reading Rialo's documentation."
        }
    };

    const quizData = [
        {
            q: { zh: "SFS 模型的核心全称是什么？", en: "What is the full name of the SFS model?" },
            o: { zh: ["Stake-for-Service", "Sell-for-Stablecoin", "Swap-for-Security", "Share-for-Sustainability"], en: ["Stake-for-Service", "Sell-for-Stablecoin", "Swap-for-Security", "Share-for-Sustainability"] },
            a: 0,
            e: { zh: "SFS 意为“为服务而质押”，是 Rialo 提出的核心经济模型。", en: "SFS stands for 'Stake-for-Service', the core economic model proposed by Rialo." }
        },
        {
            q: { zh: "在 SFS 模型中，谁是主要的原生代币质押者？", en: "In the SFS model, who is the primary staker of the native token?" },
            o: { zh: ["最终用户", "服务提供者", "流动性提供者", "硬件制造商"], en: ["End Users", "Service Providers", "Liquidity Providers", "Hardware Manufacturers"] },
            a: 1,
            e: { zh: "服务提供者必须质押代币以获得提供服务的权限。", en: "Service Providers must stake tokens to gain the rights to provide services." }
        },
        {
            q: { zh: "服务提供者通过质押可以换取什么？", en: "What do service providers get in return for staking?" },
            o: { zh: ["无限提现权限", "服务容量（Service Capacity）", "网络 100% 所有权", "免费硬件"], en: ["Unlimited Withdrawal", "Service Capacity", "100% Ownership", "Free Hardware"] },
            a: 1,
            e: { zh: "质押量决定了服务商被允许处理的任务量上限。", en: "The stake amount determines the upper limit of tasks a provider is allowed to process." }
        },
        {
            q: { zh: "SFS 与 BME 模型最大的不同在于？", en: "What is the biggest difference between SFS and the BME model?" },
            o: { zh: ["是否支持链上交易", "用户支付时是否必须涉及代币销毁", "是否需要节点", "是否具备治理"], en: ["On-chain support", "Whether token burning is required for payment", "Need for nodes", "Governance features"] },
            a: 1,
            e: { zh: "BME 要求销毁原生代币，而 SFS 允许用户直接使用稳定币。", en: "BME requires burning native tokens, whereas SFS allows users to use stablecoins directly." }
        },
        {
            q: { zh: "在 SFS 中，普通用户支付服务费主要使用？", en: "In SFS, what do ordinary users primarily use to pay for services?" },
            o: { zh: ["原生波动代币", "法币或稳定币（如 USDC）", "比特币", "积分"], en: ["Volatile Native Tokens", "Fiat or Stablecoins (e.g., USDC)", "Bitcoin", "Points"] },
            a: 1,
            e: { zh: "使用稳定资产降低了用户门槛，避免了价格波动影响。", en: "Using stable assets lowers the barrier to entry and avoids price volatility." }
        },
        {
            q: { zh: "为什么 SFS 对 AI 代理更友好？", en: "Why is SFS considered more friendly to AI Agents?" },
            o: { zh: ["无需付费", "能自动销毁代币", "可使用稳定币进行可预测结算", "必须持有代币"], en: ["No payment needed", "Auto-burn feature", "Predictable settlement with stablecoins", "Mandatory holding"] },
            a: 2,
            e: { zh: "稳定币支付消除了 AI 决策中的成本不确定性。", en: "Stablecoin payments eliminate cost uncertainty in AI decision-making." }
        },
        {
            q: { zh: "“服务容量”的分配逻辑通常是？", en: "How is 'Service Capacity' usually allocated?" },
            o: { zh: ["平均分配", "随机分配", "按质押比例分配", "按加入时间"], en: ["Equal distribution", "Randomly", "Proportional to stake", "By join date"] },
            a: 2,
            e: { zh: "质押越多，获得的服务配额越大。", en: "The more you stake, the larger your service quota." }
        },
        {
            q: { zh: "质押 20% 代币的服务商理论上获得多少配额？", en: "A provider staking 20% of the total pool theoretically gets how much quota?" },
            o: { zh: ["10%", "20%", "50%", "不确定"], en: ["10%", "20%", "50%", "Uncertain"] },
            a: 1,
            e: { zh: "配额与质押占比通常成正比。", en: "Quota is usually directly proportional to the stake ratio." }
        },
        {
            q: { zh: "SFS 如何建立竞争壁垒？", en: "How does SFS build a competitive moat?" },
            o: { zh: ["禁止新人", "要求锁定大量资本", "代码专利", "限制选择"], en: ["Banning newcomers", "Requiring large capital lock-up", "Code patents", "Restricting choice"] },
            a: 1,
            e: { zh: "质押要求为服务商设定了初始和退出成本。", en: "Staking requirements set both entry and exit costs for providers." }
        },
        {
            q: { zh: "原生代币价值捕获依赖于？", en: "Token value capture in SFS depends on?" },
            o: { zh: ["投机炒作", "服务商竞争性质押产生需求", "50% 手续费", "政府背书"], en: ["Speculation", "Competitive staking demand from providers", "50% transaction fee", "Gov backing"] },
            a: 1,
            e: { zh: "网络需求增长促使服务商质押更多代币。", en: "Growth in network demand drives providers to stake more tokens." }
        },
        {
            q: { zh: "SFS 在解决波动影响方面表现？", en: "How does SFS perform in mitigating volatility impacts?" },
            o: { zh: ["更差", "更好，因服务可用稳定币定价", "一样", "强制固定价"], en: ["Worse", "Better, as services are priced in stablecoins", "Same", "Fixed prices"] },
            a: 1,
            e: { zh: "波动风险由追求收益的服务商承担而非用户。", en: "Volatility risk is borne by profit-seeking providers rather than users." }
        },
        {
            q: { zh: "AI 代理通过 SFS 构建了？", en: "What do AI Agents build through SFS?" },
            o: { zh: ["人类市场", "机器经济体系", "广告系统", "数据库"], en: ["Human markets", "Machine Economy", "Ad system", "Database"] },
            a: 1,
            e: { zh: "实现了 M2M（机器对机器）的自动经济。", en: "It enables an automated Machine-to-Machine (M2M) economy." }
        },
        {
            q: { zh: "什么是 DePIN？", en: "What is DePIN?" },
            o: { zh: ["去中心化物理基础设施网络", "钱包协议", "隐私技术", "支付网关"], en: ["Decentralized Physical Infrastructure Networks", "Wallet protocol", "Privacy tech", "Payment gateway"] },
            a: 0,
            e: { zh: "利用区块链激励构建物理硬件网络。", en: "Building physical hardware networks using blockchain incentives." }
        },
        {
            q: { zh: "SFS 中的 Token Sink 体现在？", en: "Where is the 'Token Sink' in SFS?" },
            o: { zh: ["永久烧毁", "长期锁定在质押合约", "分给用户", "买衬衫"], en: ["Permanent burn", "Long-term lock-up in stake contracts", "User distribution", "Buying merchandise"] },
            a: 1,
            e: { zh: "锁定减少了市场供应，支撑价值。", en: "Lock-up reduces circulating supply, supporting value." }
        },
        {
            q: { zh: "新服务商加入，原有服务商配额会？", en: "When a new provider joins, existing providers' quotas will?" },
            o: { zh: ["增加", "不变", "被稀释减少", "归零"], en: ["Increase", "No change", "Be diluted/reduced", "Zero out"] },
            a: 2,
            e: { zh: "总容量按比例划分，新人会挤占份额。", en: "Total capacity is shared proportionally; newcomers take a slice of the pie." }
        },
        {
            q: { zh: "BME 的销毁在 SFS 中被替换为？", en: "Burning in BME is replaced in SFS by?" },
            o: { zh: ["赠送代币", "支付稳定资产调节需求", "强制用户质押", "免费"], en: ["Gifting tokens", "Stable asset payments regulating demand", "Mandatory user staking", "Free service"] },
            a: 1,
            e: { zh: "压力从用户转移到了专业服务商。", en: "The friction is moved from the user to the professional provider." }
        },
        {
            q: { zh: "SFS 如何确保服务商不作恶？", en: "How does SFS ensure providers don't act maliciously?" },
            o: { zh: ["靠信任", "罚没机制 (Slashing)", "封 IP", "实名"], en: ["Trust", "Slashing mechanisms", "IP bans", "KYC"] },
            a: 1,
            e: { zh: "作恶会导致质押代币被扣除。", en: "Malicious acts lead to the deduction of staked tokens." }
        },
        {
            q: { zh: "服务商主要收入来源是？", en: "The main income source for providers is?" },
            o: { zh: ["工资", "服务费 + 奖励", "价格上涨", "入场费"], en: ["Salary", "Service fees + Rewards", "Price appreciation", "Entry fees"] },
            a: 1,
            e: { zh: "结合了稳定币流和代币激励。", en: "A combination of stablecoin cash flow and token incentives." }
        },
        {
            q: { zh: "SFS 属于哪种模型分类？", en: "Which model category does SFS belong to?" },
            o: { zh: ["支付代币", "工作代币 (Work Token)", "治理代币", "稳定币"], en: ["Payment Token", "Work Token", "Governance Token", "Stablecoin"] },
            a: 1,
            e: { zh: "质押以获得工作权利。", en: "Stake to earn the right to perform work." }
        },
        {
            q: { zh: "大企业为何愿意做 SFS 服务商？", en: "Why do large enterprises want to be SFS providers?" },
            o: { zh: ["不交税", "可预测的规模和收益", "喜欢风险", "能造币"], en: ["No taxes", "Predictable scale and returns", "Risk appetite", "Coin minting"] },
            a: 1,
            e: { zh: "稳定的产能预期利于资本规划。", en: "Stable capacity expectations are beneficial for capital planning." }
        },
        {
            q: { zh: "SFS 旨在解决哪种摩擦？", en: "SFS aims to solve which type of friction?" },
            o: { zh: ["速度", "用户获取代币的门槛", "高度", "存储"], en: ["Speed", "User token acquisition barrier", "Height", "Storage"] },
            a: 1,
            e: { zh: "消除了“买代币再用服务”的麻烦。", en: "Eliminates the 'buy token to use service' hurdle." }
        },
        {
            q: { zh: "价格上涨对新进入者的挑战？", en: "The challenge of price appreciation for new entrants?" },
            o: { zh: ["没挑战", "进入成本增加", "代币清零", "降级"], en: ["None", "Higher entry cost", "Token reset", "Downgrade"] },
            a: 1,
            e: { zh: "相同份额需要更多外部资本。", en: "The same share requires more external capital." }
        },
        {
            q: { zh: "SFS 如何处理闲置容量？", en: "How does SFS handle idle capacity?" },
            o: { zh: ["强制分配", "动态调整", "销毁", "冻结"], en: ["Forced allocation", "Dynamic adjustment", "Burning", "Freezing"] },
            a: 1,
            e: { zh: "系统根据负载决定激活程度。", en: "The system determines activation based on load." }
        },
        {
            q: { zh: "供过于求时，服务商行为是？", en: "In oversupply, the rational provider behavior is?" },
            o: { zh: ["加倍质押", "撤回质押或降本", "收双倍钱", "攻击"], en: ["Double stake", "Withdraw stake or cut costs", "Double charges", "Attack"] },
            a: 1,
            e: { zh: "市场供需调节资本投入。", en: "Market supply and demand regulate capital investment." }
        },
        {
            q: { zh: "如何控制供应膨胀？", en: "How is supply inflation controlled?" },
            o: { zh: ["不控制", "锁定与减半平衡", "用户交钱", "随机销毁"], en: ["Not controlled", "Lock-up and Halving balance", "User payments", "Random burn"] },
            a: 1,
            e: { zh: "确保奖励被质押锁定吸收。", en: "Ensures rewards are absorbed by stake lock-ups." }
        },
        {
            q: { zh: "持有人不提供服务也获益？", en: "Do holders benefit without providing services?" },
            o: { zh: ["发工资", "需求增加推升单价", "免费用 AI", "变金子"], en: ["Salary", "Increased demand drives price", "Free AI", "Turn to gold"] },
            a: 1,
            e: { zh: "服务商争夺有限代币产生稀缺性。", en: "Providers competing for limited tokens creates scarcity." }
        },
        {
            q: { zh: "DePIN 质押代表了？", en: "DePIN staking represents?" },
            o: { zh: ["服务质量担保金", "纯门票", "折旧", "无意义"], en: ["Service quality guarantee", "Pure ticket", "Depreciation", "Meaningless"] },
            a: 0,
            e: { zh: "倒逼服务商维持高可用性。", en: "Forces providers to maintain high availability." }
        },
        {
            q: { zh: "是否限制特定硬件？", en: "Does it limit specific hardware?" },
            o: { zh: ["是", "不一定，看产出", "只能 CPU", "官方提供"], en: ["Yes", "Not necessarily, based on output", "CPU only", "Official only"] },
            a: 1,
            e: { zh: "关注结果和激励而非品牌。", en: "Focuses on results and incentives rather than brands." }
        },
        {
            q: { zh: "相比 SaaS 优势？", en: "Advantage over SaaS?" },
            o: { zh: ["贵", "抗审查无需许可", "垄断", "局域网"], en: ["Expensive", "Censorship-resistant & Permissionless", "Monopoly", "LAN only"] },
            a: 1,
            e: { zh: "全球可访问且无中心化控制。", en: "Global access without centralized control." }
        },
        {
            q: { zh: "Rialo 角色最接近？", en: "Rialo's role is closest to?" },
            o: { zh: ["央行", "自动规则执行者", "HR", "审核"], en: ["Central Bank", "Automated Rule Executor", "HR", "Moderator"] },
            a: 1,
            e: { zh: "协议是透明自动的结算层。", en: "The protocol is a transparent, automated settlement layer." }
        }
    ];

    let current = 0;
    let score = 0;
    let answered = false;

    function toggleLang() {
        currentLang = (currentLang === 'zh') ? 'en' : 'zh';
        updateUIStrings();
        if (document.getElementById('quiz-box').style.display !== 'none') {
            refreshQuestionText();
        } else {
            showResult(); // 刷新结果页语言
        }
    }

    function updateUIStrings() {
        const s = uiStrings[currentLang];
        document.getElementById('ui-title').innerText = s.title;
        document.getElementById('ui-subtitle').innerText = s.subtitle;
        document.getElementById('ui-q-prefix').innerText = s.qPrefix;
        document.getElementById('next-btn').innerText = s.next;
        document.getElementById('ui-res-title').innerText = s.resTitle;
        document.getElementById('ui-retry-btn').innerText = s.retry;
    }

    function refreshQuestionText() {
        const q = quizData[current];
        document.getElementById('question-text').innerText = q.q[currentLang];
        
        // 刷新选项
        const btns = document.querySelectorAll('.option');
        btns.forEach((btn, i) => {
            btn.innerHTML = `<b style="margin-right:10px">${String.fromCharCode(65+i)}.</b> ${q.o[currentLang][i]}`;
        });

        // 刷新反馈（如果已经回答过）
        if (answered) {
            const fb = document.getElementById('feedback');
            fb.innerHTML = `<strong>${uiStrings[currentLang].explanation}</strong>${q.e[currentLang]}`;
        }
    }

    function showQuestion() {
        answered = false;
        updateUIStrings();
        const q = quizData[current];
        document.getElementById('current-idx').innerText = current + 1;
        document.getElementById('progress-fill').style.width = ((current / 30) * 100) + '%';
        document.getElementById('feedback').style.display = 'none';
        document.getElementById('next-btn').style.display = 'none';
        
        const container = document.getElementById('options-container');
        container.innerHTML = '';
        
        q.o[currentLang].forEach((opt, i) => {
            const div = document.createElement('div');
            div.className = 'option';
            div.innerHTML = `<b style="margin-right:10px">${String.fromCharCode(65+i)}.</b> ${opt}`;
            div.onclick = () => select(i, div);
            container.appendChild(div);
        });
        document.getElementById('question-text').innerText = q.q[currentLang];
    }

    function select(idx, el) {
        if (answered) return;
        answered = true;
        const q = quizData[current];
        const all = document.querySelectorAll('.option');
        
        if (idx === q.a) {
            el.classList.add('correct');
            score++;
        } else {
            el.classList.add('wrong');
            all[q.a].classList.add('correct');
        }
        
        all.forEach(opt => opt.classList.add('disabled'));
        
        const fb = document.getElementById('feedback');
        fb.style.display = 'block';
        fb.innerHTML = `<strong>${uiStrings[currentLang].explanation}</strong>${q.e[currentLang]}`;
        document.getElementById('next-btn').style.display = 'block';
    }

    function nextQuestion() {
        current++;
        if (current < quizData.length) {
            showQuestion();
        } else {
            showResult();
        }
    }

    function showResult() {
        document.getElementById('quiz-box').style.display = 'none';
        document.getElementById('result-box').style.display = 'block';
        const s = Math.round((score / 30) * 100);
        document.getElementById('final-score').innerText = s;
        
        let msg = "";
        const langStrings = uiStrings[currentLang];
        if(s === 100) msg = langStrings.perfect;
        else if(s >= 80) msg = langStrings.good;
        else if(s >= 60) msg = langStrings.pass;
        else msg = langStrings.fail;
        document.getElementById('score-comment').innerText = msg;
    }

    showQuestion();
</script>

</body>
</html>